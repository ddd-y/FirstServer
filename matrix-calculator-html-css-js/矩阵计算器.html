<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>矩阵计算器</title>
    <link rel="icon" type="image/jpeg" href="./picture.jpg">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="./css/Maxtrix_main.css">
   
</head>

<body>
    <!-- 装饰元素 - 增强页面视觉吸引力 -->
    <div class="anime-decoration decoration-1"></div>
    <div class="anime-decoration decoration-2"></div>
    <div class="anime-decoration decoration-3"></div>

    <!-- 头部区域 - 包含Logo和用户操作按钮 -->
    <header>
        <div class="logo">
            <img src="./picture.jpg" alt="图片加载失败" width="70" height="70">
            <h1>矩阵计算器</h1>
        </div>

        <!-- 未登录状态：显示登录注册按钮 -->
        <div class="auth-buttons" id="auth-buttons">
            <a href="./登录页面.html"><button class="btn btn-login"><i class="fas fa-user"></i>登录</button></a>
            <a href="./登录页面.html"><button class="btn btn-register"><i class="fas fa-user-plus"></i>注册</button></a>
        </div>

        <!-- 已登录状态：显示用户信息菜单（默认隐藏） -->
        <div class="user-menu" id="user-menu" style="display: none;">
            <!-- 历史记录按钮 -->
            <button class="btn btn-history" id="btn-history">
                <i class="fas fa-history"></i> 历史记录
            </button>
            
            <!-- 用户名显示和下拉菜单 - 简化版 -->
            <div class="user-dropdown">
                <button class="btn btn-user" id="btn-user">
                    <i class="fas fa-user-circle"></i>
                    <span id="username-display">用户名</span>
                    <i class="fas fa-caret-down"></i>
                </button>
                <!-- 简化下拉菜单，只包含退出登录 -->
                <div class="dropdown-content" id="dropdown-content">
                    <a href="javascript:void(0);" id="logout-link">
                        <i class="fas fa-sign-out-alt"></i> 退出登录
                    </a>
                </div>
            </div>
        </div>
    </header>

    <!-- 主内容区 - 侧边栏和矩阵输入区 -->
    <div class="main-container">
        <!-- 侧边栏 - 矩阵运算选项列表 -->
        <div class="sidebar">
            <h2><i class="fas fa-th-list"></i> 矩阵运算</h2>
            <ul class="operation-list">
                <li class="operation-item active">
                    <img src="2DE403D599087593F7149AE22D7FE342.jpeg" alt="" width="70" height="50">
                    <span>矩阵加法</span>
                </li>
                <li class="operation-item">
                    <img src="./42D3098AF5CDB73D87CD46ED022AE734.jpeg" alt="" width="70" height="50">
                    <span>矩阵减法</span>
                </li>
                <li class="operation-item">
                    <img src="./0BDF5459AB038AA23E0AA858F68CB546.jpeg" alt="" width="70" height="50">
                    <span>矩阵乘法</span>
                </li>
                <li class="operation-item">
                    <img src="./999BB0D4D1482C0E636FB6B9C2157804.jpeg" alt="" width="70" height="50">
                    <span>矩阵转置</span>
                </li>
                <li class="operation-item">
                    <img src="./AD4A6F1EB3AEDDEE93DBE4DD04CD2C2C.jpeg" alt="" width="70" height="50">
                    <span>矩阵求逆</span>
                </li>
            </ul>

            <!-- 侧边栏新增：可视化平台入口 -->
            <div style="margin-top: 30px; border-top: 1px solid rgba(0,0,0,0.1); padding-top: 20px;">
                <h2 style="font-size: 1.1em; color: #555;"><i class="fas fa-eye"></i> 交互学习</h2>
                <ul class="operation-list">
                    <li class="operation-item" id="nav-viz-platform">
                        <div style="width: 70px; height: 50px; display: flex; align-items: center; justify-content: center; background: #f0f2f5; border-radius: 5px; color: #667eea;">
                            <i class="fas fa-cube" style="font-size: 24px;"></i>
                        </div>
                        <span>可视化平台</span>
                    </li>
                </ul>
            </div>
        </div>

        <!-- 矩阵输入区 - 包含矩阵输入、计算和结果显示 -->
        <div class="matrix-container" id="calculation-mode">
            <div class="matrix-header">
                <h2><i class="fas fa-keyboard"></i> 矩阵输入</h2>
                <div class="matrix-controls">
                    <!-- 服务器状态指示器 -->
                    <div class="server-status" id="server-status">
                        <i class="fas fa-circle"></i>
                        <span id="server-status-text">本地计算模式</span>
                    </div>
                    <div class="matrix-size">
                        <span>行数:</span>
                        <input type="number" id="rows" min="1" max="10" value="3">
                    </div>
                    <div class="matrix-size">
                        <span>列数:</span>
                        <input type="number" id="cols" min="1" max="10" value="3">
                    </div>
                    <button class="btn" id="update-matrix">
                        <i class="fas fa-sync-alt"></i> 更新矩阵
                    </button>
                </div>
            </div>
            
            <div class="matrix-input-area">
                <!-- 矩阵A输入区域 -->
                <div class="matrix-title">
                    <i class="fas fa-th"></i> 矩阵 A
                </div>
                <div class="matrix-grid-container">
                    <div class="matrix-grid" id="matrixA">
                        <!-- 矩阵A输入框将通过JS动态生成 -->
                    </div>
                </div>
                <div class="fraction-hint">提示：可以使用分数格式输入，如 1/2, 3/4</div>
                
                <!-- 矩阵B输入区域 - 根据操作类型显示或隐藏 -->
                <div class="matrix-title" id="matrixB-title">
                    <i class="fas fa-th"></i> 矩阵 B
                </div>
                <div class="matrix-grid-container" id="matrixB-container">
                    <div class="matrix-grid" id="matrixB">
                        <!-- 矩阵B输入框将通过JS动态生成 -->
                    </div>
                </div>
                <div class="fraction-hint" id="matrixB-hint">提示：可以使用分数格式输入，如 1/2, 3/4</div>
                
                <!-- 计算按钮 -->
                <button class="calculate-btn" id="calculate-btn">
                    <i class="fas fa-calculator"></i> 计算
                </button>
                
                <!-- 结果区域 - 显示计算结果 -->
                <div class="result-area">
                    <h3><i class="fas fa-poll"></i> 计算结果</h3>
                    <p id="result-message">请选择运算类型并输入矩阵数据，然后点击计算按钮查看结果。</p>
                    
                    <!-- 结果矩阵展示区域 -->
                    <div class="result-matrix" id="resultMatrix" style="display: none;">
                        <div class="matrix-title">
                            <i class="fas fa-th"></i> 结果矩阵
                        </div>
                        <div class="result-grid" id="resultGrid">
                            <!-- 结果矩阵将通过JS动态生成 -->
                        </div>
                    </div>
                    
                    <!-- 消息区域 -->
                    <div id="message-area"></div>
                </div>
            </div>
        </div>

        <!-- 可视化平台区域 - 默认隐藏 -->
        <div class="visualization-area" id="visualization-mode">
            <div class="matrix-header">
                <h2><i class="fas fa-cube"></i> 线性变换可视化</h2>
                <div class="matrix-controls">
                    <button class="btn" id="btn-reset-viz">
                        <i class="fas fa-redo"></i> 重置视图
                    </button>
                </div>
            </div>

            <div class="viz-content fade-in">
                <!-- 画布区域 -->
                <div class="canvas-wrapper" id="canvas-container">
                    <canvas id="vizCanvas"></canvas>
                    <div class="viz-overlay-info">
                        基向量: <span style="color:#2ecc71; font-weight:bold">i-hat (1,0)</span>, 
                        <span style="color:#e74c3c; font-weight:bold">j-hat (0,1)</span>
                    </div>
                </div>

                <!-- 控制面板 -->
                <div class="viz-controls-panel">
                    <div class="viz-control-group">
                        <h4><i class="fas fa-magic"></i> 变换矩阵</h4>
                        <p style="font-size: 0.9em; color: #666; margin-bottom: 10px;">输入 2x2 矩阵来定义线性变换：</p>
                        <div class="matrix-input-compact">
                            <input type="number" id="viz-m11" value="1" step="0.1" placeholder="1">
                            <input type="number" id="viz-m12" value="1" step="0.1" placeholder="0">
                            <input type="number" id="viz-m21" value="0" step="0.1" placeholder="0">
                            <input type="number" id="viz-m22" value="1" step="0.1" placeholder="1">
                        </div>
                        <button class="calculate-btn" id="btn-apply-transform" style="width: 100%; margin: 0;">
                            <i class="fas fa-play"></i> 应用变换动画
                        </button>
                    </div>

                    <!-- 新增：平移和特征向量控制 -->
                    <div class="viz-control-group">
                        <h4><i class="fas fa-arrows-alt"></i> 平移 & 特征向量</h4>
                        <p style="font-size: 0.9em; color: #666; margin-bottom: 10px;">平移网格或观察特征向量：</p>
                        
                        <label style="font-size: 0.9em; font-weight: bold; display: block; margin-bottom: 5px;">平移向量 (x, y):</label>
                        <div class="matrix-input-compact">
                            <input type="number" id="viz-tx" value="0" step="0.5" placeholder="x">
                            <input type="number" id="viz-ty" value="0" step="0.5" placeholder="y">
                        </div>

                        <div style="margin-top: 15px;">
                             <label style="display: flex; align-items: center; cursor: pointer; gap: 10px;">
                                <input type="checkbox" id="show-eigenvectors" style="width: 18px; height: 18px;">
                                <span style="font-weight: 500; color: #333;">显示特征向量 (Eigenvectors)</span>
                            </label>
                            <p style="font-size: 0.8em; color: #888; margin-top: 5px; margin-left: 28px;">
                                黄色线条表示特征向量方向，仅在存在实数特征值时显示。
                            </p>
                        </div>
                    </div>

                    <div class="viz-control-group">
                        <h4><i class="fas fa-star"></i> 经典变换预设</h4>
                        <p style="font-size: 0.9em; color: #666; margin-bottom: 10px;">点击体验常见的线性变换：</p>
                        <div class="preset-buttons">
                            <button class="btn-preset" onclick="setVizMatrix(1, 1, 0, 1)">剪切 (Shear)</button>
                            <button class="btn-preset" onclick="setVizMatrix(0, -1, 1, 0)">旋转 90°</button>
                            <button class="btn-preset" onclick="setVizMatrix(2, 0, 0, 2)">放大 2x</button>
                            <button class="btn-preset" onclick="setVizMatrix(0, 1, 1, 0)">反射 y=x</button>
                            <button class="btn-preset" onclick="setVizMatrix(1, 0, 0, 0)">投影到 X轴</button>
                            <button class="btn-preset" onclick="setVizMatrix(-1, 0, 0, 1)">水平翻转</button>
                        </div>
                    </div>
                </div>

                <div class="viz-description">
                    <i class="fas fa-lightbulb" style="font-size: 20px;"></i>
                    <div>
                        <strong>线性代数的本质：</strong> 观察网格线如何保持 <em>平行</em> 且 <em>等距分布</em>。
                        绿色箭头代表 $\hat{i}$ 基向量，红色箭头代表 $\hat{j}$ 基向量。矩阵的列正是变换后的基向量坐标。
                        <br>
                        <strong>特征向量：</strong> 在变换中方向不发生改变的非零向量（仅发生缩放）。
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    // ===== 全局变量和配置 =====
    // 第一类服务器地址（用户认证和历史记录）
    const BASE_URL = 'http://192.168.78.129:8081'; // 替换为实际地址
    
    // 第二类服务器地址（矩阵计算服务）- 从登录信息获取或使用默认值
    let secondServerUrl = 'http://192.168.78.131:8081';
    
    // 当前选中的操作
    let currentOperation = '矩阵加法';
    
    // 键盘导航相关变量
    let currentMatrix = 'A'; // 当前活动的矩阵 (A 或 B)
    let currentRow = 0;      // 当前行索引
    let currentCol = 0;      // 当前列索引
    
    // ===== DOM元素获取 =====
    const matrixA = document.getElementById('matrixA');
    const matrixB = document.getElementById('matrixB');
    const matrixBTitle = document.getElementById('matrixB-title');
    const matrixBContainer = document.getElementById('matrixB-container');
    const matrixBHint = document.getElementById('matrixB-hint');
    const resultGrid = document.getElementById('resultGrid');
    const resultMatrix = document.getElementById('resultMatrix');
    const resultMessage = document.getElementById('result-message');
    const messageArea = document.getElementById('message-area');
    const calculateBtn = document.getElementById('calculate-btn');
    const serverStatus = document.getElementById('server-status');
    const serverStatusText = document.getElementById('server-status-text');
    
    // 页面模式切换元素
    const calculationModeDiv = document.getElementById('calculation-mode');
    const visualizationModeDiv = document.getElementById('visualization-mode');
    const vizPlatformBtn = document.getElementById('nav-viz-platform');

    // ===== 矩阵初始化函数 =====
    function initializeMatrix() {
        const rows = parseInt(document.getElementById('rows').value);
        const cols = parseInt(document.getElementById('cols').value);
        
        // 生成矩阵A
        matrixA.innerHTML = '';
        matrixA.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'matrix-cell';
                input.placeholder = '0';
                input.value = Math.floor(Math.random() * 5 + 1);
                input.dataset.row = i;
                input.dataset.col = j;
                input.dataset.matrix = 'A';
                
                // 添加键盘事件监听
                input.addEventListener('keydown', handleKeyDown);
                input.addEventListener('focus', handleFocus);
                
                matrixA.appendChild(input);
            }
        }
        
        // 根据操作类型决定是否生成矩阵B
        if (currentOperation === '矩阵转置' || currentOperation === '矩阵求逆') {
            // 单矩阵操作，隐藏矩阵B
            matrixBContainer.style.display = 'none';
            matrixBTitle.style.display = 'none';
            matrixBHint.style.display = 'none';
        } else {
            // 双矩阵操作，显示矩阵B
            matrixBContainer.style.display = 'block';
            matrixBTitle.style.display = 'flex';
            matrixBHint.style.display = 'block';
            
            matrixB.innerHTML = '';
            matrixB.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'matrix-cell';
                    input.placeholder = '0';
                    input.value = Math.floor(Math.random() * 5 + 1);
                    input.dataset.row = i;
                    input.dataset.col = j;
                    input.dataset.matrix = 'B';
                    
                    // 添加键盘事件监听
                    input.addEventListener('keydown', handleKeyDown);
                    input.addEventListener('focus', handleFocus);
                    
                    matrixB.appendChild(input);
                }
            }
        }
        
        // 重置当前焦点位置
        currentRow = 0;
        currentCol = 0;
        currentMatrix = 'A';
        
        // 隐藏结果矩阵
        resultMatrix.style.display = 'none';
        clearMessage();
    }
    
    // ===== 键盘导航功能 =====
    function handleKeyDown(event) {
        const key = event.key;
        const rows = parseInt(document.getElementById('rows').value);
        const cols = parseInt(document.getElementById('cols').value);
        
        // 更新当前焦点位置
        currentRow = parseInt(event.target.dataset.row);
        currentCol = parseInt(event.target.dataset.col);
        currentMatrix = event.target.dataset.matrix;
        
        // 处理方向键
        if (key === 'ArrowUp' || key === 'ArrowDown' || 
            key === 'ArrowLeft' || key === 'ArrowRight') {
            event.preventDefault();
            
            let newRow = currentRow;
            let newCol = currentCol;
            let newMatrix = currentMatrix;
            
            // 根据按键计算新的位置
            switch (key) {
                case 'ArrowUp':
                    newRow = Math.max(0, currentRow - 1);
                    break;
                case 'ArrowDown':
                    newRow = Math.min(rows - 1, currentRow + 1);
                    break;
                case 'ArrowLeft':
                    newCol = Math.max(0, currentCol - 1);
                    break;
                case 'ArrowRight':
                    newCol = Math.min(cols - 1, currentCol + 1);
                    break;
            }
            
            // 查找并聚焦到新的输入框
            const newInput = document.querySelector(
                `.matrix-cell[data-matrix="${newMatrix}"][data-row="${newRow}"][data-col="${newCol}"]`
            );
            
            if (newInput) {
                newInput.focus();
                newInput.select();
            }
        }
    }
    
    function handleFocus(event) {
        currentRow = parseInt(event.target.dataset.row);
        currentCol = parseInt(event.target.dataset.col);
        currentMatrix = event.target.dataset.matrix;
    }
    
    // ===== 消息显示函数 =====
    function showMessage(message, type = 'error') {
        messageArea.innerHTML = `<div class="message ${type}">${message}</div>`;
    }
    
    function clearMessage() {
        messageArea.innerHTML = '';
    }
    
    // ===== 分数处理函数 =====
    function parseFraction(value) {
        if (value.includes('/')) {
            const parts = value.split('/');
            if (parts.length === 2) {
                const numerator = parseFloat(parts[0]);
                const denominator = parseFloat(parts[1]);
                if (!isNaN(numerator) && !isNaN(denominator) && denominator !== 0) {
                    return numerator / denominator;
                }
            }
            return NaN;
        }
        
        return parseFloat(value);
    }
    
    // ===== 获取矩阵数据 =====
    function getMatrixData(matrixElement) {
        const rows = parseInt(document.getElementById('rows').value);
        const cols = parseInt(document.getElementById('cols').value);
        const inputs = matrixElement.querySelectorAll('.matrix-cell');
        const matrix = [];
        
        for (let i = 0; i < rows; i++) {
            const row = [];
            for (let j = 0; j < cols; j++) {
                const index = i * cols + j;
                const value = inputs[index].value.trim();
                
                if (value === '') {
                    row.push(0);
                } else {
                    const numValue = parseFraction(value);
                    if (isNaN(numValue)) {
                        throw new Error(`位置 (${i+1}, ${j+1}) 的值 "${value}" 不是有效的数字或分数`);
                    }
                    row.push(numValue);
                }
            }
            matrix.push(row);
        }
        
        return matrix;
    }
    
    // ===== 本地计算函数 =====
    function localAddition(matrixA, matrixB) {
        const rows = matrixA.length;
        const cols = matrixA[0].length;
        const result = [];
        
        for (let i = 0; i < rows; i++) {
            const row = [];
            for (let j = 0; j < cols; j++) {
                row.push(matrixA[i][j] + matrixB[i][j]);
            }
            result.push(row);
        }
        
        return result;
    }
    
    function localSubtraction(matrixA, matrixB) {
        const rows = matrixA.length;
        const cols = matrixA[0].length;
        const result = [];
        
        for (let i = 0; i < rows; i++) {
            const row = [];
            for (let j = 0; j < cols; j++) {
                row.push(matrixA[i][j] - matrixB[i][j]);
            }
            result.push(row);
        }
        
        return result;
    }
    
    // ===== 远程计算函数（调用第二类服务器）=====
    async function remoteCalculation(operation, matrixAData, matrixBData) {
        try {
            // 准备请求数据
            const requestData = {
                operation: operation,
                rowsA: matrixAData.length,
                colsA: matrixAData[0].length,
                matrixA: matrixAData
            };
            
            // 如果是乘法操作，添加矩阵B
            if (operation === '矩阵乘法' && matrixBData) {
                requestData.matrixB = matrixBData;
                requestData.rowsB=matrixBData.length;
                requestData.colsB=matrixBData[0].length;
            }
            
            // 更新服务器状态
            serverStatusText.textContent = '远程计算中...';
            serverStatus.innerHTML = '<i class="fas fa-sync-alt fa-spin"></i><span id="server-status-text">远程计算中...</span>';
            
            // 显示加载状态
            calculateBtn.disabled = true;
            calculateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 计算中...';
            
            console.log('发送到第二类服务器的请求:', {
                url: `${secondServerUrl}/api/matrix/calculate`,
                data: requestData
            });
            
            // 发送请求到第二类服务器
            const response = await fetch(`${secondServerUrl}/api/matrix/calculate`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestData)
            });
            
            if (!response.ok) {
                throw new Error(`第二类服务器错误: ${response.status} ${response.statusText}`);
            }
            
            const result = await response.json();
            
            // 恢复按钮状态
            calculateBtn.disabled = false;
            calculateBtn.innerHTML = '<i class="fas fa-calculator"></i> 计算';
            
            // 更新服务器状态
            serverStatusText.textContent = '远程计算完成';
            serverStatus.innerHTML = '<i class="fas fa-circle"></i><span id="server-status-text">远程计算完成</span>';
            
            console.log('第二类服务器返回结果:', result);
            
            return result;
        } catch (error) {
            // 恢复按钮状态
            calculateBtn.disabled = false;
            calculateBtn.innerHTML = '<i class="fas fa-calculator"></i> 计算';
            
            // 更新服务器状态
            serverStatusText.textContent = '远程计算失败';
            serverStatus.innerHTML = '<i class="fas fa-circle offline"></i><span id="server-status-text">远程计算失败</span>';
            
            throw error;
        }
    }
    
    // ===== 发送计算记录到第一类服务器 =====
    async function sendCalculationRecord(operation, matrixAData, matrixBData, result) {
        try {
            const authToken = localStorage.getItem('authToken');
            const userId = localStorage.getItem('user_id');
            
            if (!authToken) {
                console.log('用户未登录，跳过记录保存');
                return null;
            }
            
            // 构建请求体 - 匹配第一类服务器API
            const recordData = {
                operation: operation,
                input_matrix_dense: matrixAData,
                output_matrix_dense: result.matrix
            };
            
            // 如果有矩阵B数据，也添加进去
            if (matrixBData) {
                requestData.input_matrix_dense_b = matrixBData;
            }
            
            // 设置请求头
            const headers = {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
            };
            
            console.log('发送到第一类服务器的记录:', JSON.stringify(recordData));
            
            // 发送记录到第一类服务器
            const response = await fetch(`${BASE_URL}/api/auth/add_history`, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(recordData)
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error('记录保存失败:', response.status, errorText);
                return {
                    success: false,
                    message: `第一类服务器错误: ${response.status}`
                };
            }
            
            const responseData = await response.json();
            console.log('计算记录已保存到第一类服务器:', responseData);
            
            return {
                success: true,
                data: responseData
            };
        } catch (error) {
            console.error('保存计算记录失败:', error);
            return {
                success: false,
                message: error.message
            };
        }
    }
    
    // ===== 显示结果矩阵 =====
    function displayResultMatrix(result) {
        const rows = result.rows;
        const cols = result.cols;
        const matrix = result.matrix;
        
        resultGrid.innerHTML = '';
        resultGrid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                const cell = document.createElement('div');
                cell.className = 'result-cell';
                
                const value = matrix[i][j];
                // 判断是否为数值，如果是数值则格式化，否则直接显示
                if (typeof value === 'number') {
                    cell.textContent = Math.abs(value) < 0.0001 ? 0 : value.toFixed(4);
                } else {
                    cell.textContent = value;
                }
                
                resultGrid.appendChild(cell);
            }
        }
        
        resultMatrix.style.display = 'block';
    }
    
    // ===== 计算按钮事件 =====
    calculateBtn.addEventListener('click', async function() {
        try {
            // 获取矩阵A数据
            const matrixAData = getMatrixData(matrixA);
            
            // 根据操作类型选择计算方式
            if (currentOperation === '矩阵加法') {
                // 本地加法计算
                const matrixBData = getMatrixData(matrixB);
                const result = localAddition(matrixAData, matrixBData);
                
                displayResultMatrix({
                    rows: matrixAData.length,
                    cols: matrixAData[0].length,
                    matrix: result
                });
                resultMessage.textContent = `矩阵加法计算结果如下：`;
                
                // 发送记录到第一类服务器
                const saveResult = await sendCalculationRecord(currentOperation, matrixAData, matrixBData, {
                    rows: matrixAData.length,
                    cols: matrixAData[0].length,
                    matrix: result
                });
                
                if (saveResult && !saveResult.success) {
                    showMessage(`计算成功，但保存记录失败: ${saveResult.message}`, 'warning');
                }
            } 
            else if (currentOperation === '矩阵减法') {
                // 本地减法计算
                const matrixBData = getMatrixData(matrixB);
                const result = localSubtraction(matrixAData, matrixBData);
                
                displayResultMatrix({
                    rows: matrixAData.length,
                    cols: matrixAData[0].length,
                    matrix: result
                });
                resultMessage.textContent = `矩阵减法计算结果如下：`;
                
                // 发送记录到第一类服务器
                const saveResult = await sendCalculationRecord(currentOperation, matrixAData, matrixBData, {
                    rows: matrixAData.length,
                    cols: matrixAData[0].length,
                    matrix: result
                });
                
                if (saveResult && !saveResult.success) {
                    showMessage(`计算成功，但保存记录失败: ${saveResult.message}`, 'warning');
                }
            } 
            else if (currentOperation === '矩阵转置') {
                // 检查第二类服务器连接
                if (!secondServerUrl || secondServerUrl.includes('your-second-server.com')) {
                    throw new Error('第二类服务器未配置，无法进行远程计算');
                }
                
                // 远程计算（第二类服务器）
                const result = await remoteCalculation(currentOperation, matrixAData);
                
                displayResultMatrix(result);
                resultMessage.textContent = `矩阵转置计算结果如下：`;
                
                // 发送记录到第一类服务器
                currentOperation = 'transpose';
                const saveResult = await sendCalculationRecord(currentOperation, matrixAData, null, result);
                
                if (saveResult && !saveResult.success) {
                    showMessage(`计算成功，但保存记录失败: ${saveResult.message}`, 'warning');
                }
            }
            else if (currentOperation === '矩阵乘法') {
                // 检查第二类服务器连接
                if (!secondServerUrl || secondServerUrl.includes('your-second-server.com')) {
                    throw new Error('第二类服务器未配置，无法进行远程计算');
                }
                
                const matrixBData = getMatrixData(matrixB);
                const rowsA = matrixAData.length;
                const colsA = matrixAData[0].length;
                const rowsB = matrixBData.length;
                const colsB = matrixBData[0].length;
                
                if (colsA !== rowsB) {
                    throw new Error('矩阵A的列数必须等于矩阵B的行数才能进行乘法运算');
                }
                
                // 远程计算（第二类服务器）
                const result = await remoteCalculation(currentOperation, matrixAData, matrixBData);
                
                displayResultMatrix(result);
                resultMessage.textContent = `矩阵乘法计算结果如下：`;
                
                // 发送记录到第一类服务器
                const saveResult = await sendCalculationRecord(currentOperation, matrixAData, matrixBData, result);
                
                if (saveResult && !saveResult.success) {
                    showMessage(`计算成功，但保存记录失败: ${saveResult.message}`, 'warning');
                }
            }
            else if (currentOperation === '矩阵求逆') {
                // 检查第二类服务器连接
                if (!secondServerUrl || secondServerUrl.includes('your-second-server.com')) {
                    throw new Error('第二类服务器未配置，无法进行远程计算');
                }
                
                const size = matrixAData.length;
                
                if (size !== matrixAData[0].length) {
                    throw new Error('只有方阵才能求逆');
                }
                
                // 远程计算（第二类服务器）
                currentOperation = 'inverse';
                const result = await remoteCalculation(currentOperation, matrixAData);
                
                displayResultMatrix(result);
                resultMessage.textContent = `矩阵求逆计算结果如下：`;
                
                // 发送记录到第一类服务器
                const saveResult = await sendCalculationRecord(currentOperation, matrixAData, null, result);
                
                if (saveResult && !saveResult.success) {
                    showMessage(`计算成功，但保存记录失败: ${saveResult.message}`, 'warning');
                }
            }
            
            clearMessage();
        } catch (error) {
            showMessage(`计算错误: ${error.message}`);
            console.error('计算错误:', error);
        }
    });
    
    // ===== 更新矩阵按钮事件 =====
    document.getElementById('update-matrix').addEventListener('click', initializeMatrix);
    
    // ===== 侧边栏操作项点击事件 =====
    const operationItems = document.querySelectorAll('.operation-list .operation-item:not(#nav-viz-platform)');
    operationItems.forEach(item => {
        item.addEventListener('click', function() {
            // 切换回计算模式
            calculationModeDiv.style.display = 'block';
            visualizationModeDiv.style.display = 'none';
            vizPlatformBtn.classList.remove('active');

            operationItems.forEach(i => i.classList.remove('active'));
            this.classList.add('active');
            
            currentOperation = this.querySelector('span').textContent;
            
            document.querySelector('.matrix-header h2').innerHTML = 
                `<i class="fas fa-keyboard"></i> ${currentOperation} - 矩阵输入`;
            
            // 更新服务器状态显示
            if (currentOperation === '矩阵加法' || currentOperation === '矩阵减法') {
                serverStatusText.textContent = '本地计算模式';
                serverStatus.innerHTML = '<i class="fas fa-circle"></i><span id="server-status-text">本地计算模式</span>';
            } else {
                // 检查第二类服务器是否可用
                if (!secondServerUrl || secondServerUrl.includes('your-second-server.com')) {
                    serverStatusText.textContent = '第二类服务器未配置';
                    serverStatus.innerHTML = '<i class="fas fa-circle offline"></i><span id="server-status-text">第二类服务器未配置</span>';
                } else {
                    serverStatusText.textContent = '远程计算模式';
                    serverStatus.innerHTML = '<i class="fas fa-circle"></i><span id="server-status-text">远程计算模式</span>';
                }
            }
            
            initializeMatrix();
        });
    });

    // ===== 可视化平台入口点击事件 =====
    vizPlatformBtn.addEventListener('click', function() {
        // 移除其他激活状态
        operationItems.forEach(i => i.classList.remove('active'));
        this.classList.add('active');

        // 切换界面
        calculationModeDiv.style.display = 'none';
        visualizationModeDiv.style.display = 'block';

        // 初始化Canvas
        setTimeout(initVizCanvas, 100);
    });
    
    // ===== 页面加载初始化 =====
    window.addEventListener('DOMContentLoaded', function() {
        initializeMatrix();
        
        // 检查第二类服务器配置
        if (secondServerUrl && !secondServerUrl.includes('your-second-server.com')) {
            console.log('第二类服务器已配置:', secondServerUrl);
        } else {
            console.warn('第二类服务器未配置，使用默认值');
        }
        
        // 初始焦点设置
        const firstInput = document.querySelector('.matrix-cell');
        if (firstInput) {
            firstInput.focus();
        }
    });
    
    // ===== 检查登录状态 =====
    async function checkLoginStatus() {
        try {
            const authToken = localStorage.getItem('authToken');
            const username = localStorage.getItem('username');
            const user_id = localStorage.getItem('user_id');
            
            // 如果没有 user_id 但有 username，使用 username 作为后备
            if (!user_id && username) {
                localStorage.setItem('user_id', username);
            }
            
            if (username && authToken) {
                try {
                    // 使用get_records验证token
                    const response = await fetch(`${BASE_URL}/api/auth/get_records?page=1&limit=1`, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${authToken}`
                        }
                    });
                    
                    if (response.ok) {
                        document.getElementById('auth-buttons').style.display = 'none';
                        document.getElementById('user-menu').style.display = 'flex';
                        document.getElementById('username-display').textContent = username;
                        
                        // 获取并显示第二类服务器IP（如果存在）
                        const serverIp = localStorage.getItem('server_ip');
                        if (serverIp) {
                            secondServerUrl = serverIp;
                            console.log('第二类服务器IP地址:', secondServerUrl);
                        }
                        
                        console.log('用户已登录:', username);
                        return true;
                    } else {
                        console.log('Token验证失败，清除用户数据');
                        clearUserData();
                        return false;
                    }
                } catch (apiError) {
                    console.error('验证Token时出错:', apiError);
                    document.getElementById('auth-buttons').style.display = 'none';
                    document.getElementById('user-menu').style.display = 'flex';
                    document.getElementById('username-display').textContent = username;
                    return true;
                }
            } else {
                clearUserData();
                return false;
            }
        } catch (error) {
            console.error('检查登录状态失败:', error);
            clearUserData();
            return false;
        }
    }
    
    // ===== 清除用户数据 =====
    function clearUserData() {
        localStorage.removeItem('authToken');
        localStorage.removeItem('username');
        localStorage.removeItem('user_id');
        
        document.getElementById('auth-buttons').style.display = 'flex';
        document.getElementById('user-menu').style.display = 'none';
    }
    
    // ===== 用户菜单功能 =====
    document.getElementById('btn-history').addEventListener('click', function() {
        window.location.href = './历史记录页面.html';
    });
    
    document.getElementById('logout-link').addEventListener('click', async function() {
        if (confirm('确定要退出登录吗？')) {
            const authToken = localStorage.getItem('authToken');
            
            try {
                if (authToken) {
                    const response = await fetch(`${BASE_URL}/api/auth/logout`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${authToken}`,
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`登出请求失败: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    console.log('登出成功:', data);
                }
            } catch (error) {
                console.error('登出请求失败:', error);
            } finally {
                clearUserData();
                window.location.href = './登录页面.html';
            }
        }
    });
    
    // ===== 下拉菜单控制 =====
    const userDropdown = document.querySelector('.user-dropdown');
    const dropdownContent = document.getElementById('dropdown-content');
    const btnUser = document.getElementById('btn-user');
    let dropdownTimeout = null;
    
    function showDropdown() {
        if (dropdownTimeout) {
            clearTimeout(dropdownTimeout);
            dropdownTimeout = null;
        }
        
        dropdownContent.classList.add('show');
    }
    
    function hideDropdown() {
        dropdownTimeout = setTimeout(() => {
            dropdownContent.classList.remove('show');
            dropdownTimeout = null;
        }, 300);
    }
    
    function cancelHideDropdown() {
        if (dropdownTimeout) {
            clearTimeout(dropdownTimeout);
            dropdownTimeout = null;
        }
    }
    
    btnUser.addEventListener('click', function(e) {
        e.stopPropagation();
        
        if (dropdownContent.classList.contains('show')) {
            hideDropdown();
        } else {
            showDropdown();
        }
    });
    
    btnUser.addEventListener('mouseenter', function() {
        showDropdown();
    });
    
    btnUser.addEventListener('mouseleave', function() {
        hideDropdown();
    });
    
    dropdownContent.addEventListener('mouseenter', function() {
        cancelHideDropdown();
    });
    
    dropdownContent.addEventListener('mouseleave', function() {
        hideDropdown();
    });
    
    document.addEventListener('click', function(e) {
        if (!userDropdown.contains(e.target)) {
            dropdownContent.classList.remove('show');
        }
    });
    
    // ===== 页面加载时初始化 =====
    document.addEventListener('DOMContentLoaded', async function() {
        await checkLoginStatus();
        
        window.addEventListener('storage', function(e) {
            if (e.key === 'username' || e.key === 'authToken' || e.key === 'user_id') {
                checkLoginStatus();
            }
        });
    });
    
    // ===== 登录成功后的UI更新函数 =====
    function updateUIAfterLogin(username, token, userId) {
        localStorage.setItem('username', username);
        localStorage.setItem('authToken', token);
        localStorage.setItem('user_id', userId);
        
        checkLoginStatus();
        
        console.log('UI已更新，用户已登录:', username);
    }

    // ============================================
    // ===== 线性代数可视化引擎 (3Blue1Brown风格) =====
    // ============================================
    
    const vizCanvas = document.getElementById('vizCanvas');
    let ctx = null;
    let vizWidth, vizHeight;
    let vizAnimationId = null;
    
    // 变换状态
    let currentVizMatrix = { a: 1, b: 0, c: 0, d: 1 }; // 当前显示的矩阵状态
    let targetVizMatrix = { a: 1, b: 0, c: 0, d: 1 };  // 目标矩阵
    let startVizMatrix = { a: 1, b: 0, c: 0, d: 1 };   // 动画开始时的矩阵
    
    // 新增：平移状态
    let currentVizTranslation = { x: 0, y: 0 };
    let targetVizTranslation = { x: 0, y: 0 };
    let startVizTranslation = { x: 0, y: 0 };

    let animationStartTime = 0;
    let isVizAnimating = false;
    const ANIMATION_DURATION = 1500; // 毫秒
    
    // 初始化画布
    function initVizCanvas() {
        if (!vizCanvas) return;
        const container = document.getElementById('canvas-container');
        vizCanvas.width = container.clientWidth;
        vizCanvas.height = container.clientHeight;
        vizWidth = vizCanvas.width;
        vizHeight = vizCanvas.height;
        ctx = vizCanvas.getContext('2d');
        
        // 初始绘制
        drawVizFrame();
    }
    
    // 窗口大小改变时重置画布
    window.addEventListener('resize', () => {
        if (visualizationModeDiv.style.display !== 'none') {
            initVizCanvas();
        }
    });
    
    // 设置可视化矩阵（用于预设按钮）
    window.setVizMatrix = function(a, b, c, d) {
        document.getElementById('viz-m11').value = a;
        document.getElementById('viz-m12').value = b;
        document.getElementById('viz-m21').value = c;
        document.getElementById('viz-m22').value = d;
        // 重置平移
        document.getElementById('viz-tx').value = 0;
        document.getElementById('viz-ty').value = 0;
        
        startVizAnimation();
    };
    
    // 启动动画
    function startVizAnimation() {
        const m11 = parseFloat(document.getElementById('viz-m11').value) || 1;
        const m12 = parseFloat(document.getElementById('viz-m12').value) || 0;
        const m21 = parseFloat(document.getElementById('viz-m21').value) || 0;
        const m22 = parseFloat(document.getElementById('viz-m22').value) || 1;
        
        const tx = parseFloat(document.getElementById('viz-tx').value) || 0;
        const ty = parseFloat(document.getElementById('viz-ty').value) || 0;

        startVizMatrix = { ...currentVizMatrix };
        startVizTranslation = { ...currentVizTranslation };

        // 注意：Canvas坐标系变换中，m11是i_new.x, m21是i_new.y，m12是j_new.x，m22是j_new.y
        // 我们假设输入是 [[a, c], [b, d]] (列向量形式)
        // a=m11, b=m21, c=m12, d=m22
        
        targetVizMatrix = {
            a: m11, // i_new.x
            b: m21, // i_new.y
            c: m12, // j_new.x
            d: m22  // j_new.y
        };
        
        targetVizTranslation = { x: tx, y: ty };

        animationStartTime = performance.now();
        isVizAnimating = true;
        
        if (!vizAnimationId) {
            vizLoop();
        }
    }
    
    document.getElementById('btn-apply-transform').addEventListener('click', startVizAnimation);
    
    document.getElementById('btn-reset-viz').addEventListener('click', () => {
        setVizMatrix(1, 0, 0, 1);
    });
    
    // 缓动函数
    function easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }
    
    // 动画循环
    function vizLoop() {
        if (!isVizAnimating) {
            vizAnimationId = null;
            return;
        }
        
        const now = performance.now();
        const elapsed = now - animationStartTime;
        let progress = Math.min(elapsed / ANIMATION_DURATION, 1);
        
        progress = easeInOutCubic(progress);
        
        // 插值计算当前矩阵
        currentVizMatrix.a = startVizMatrix.a + (targetVizMatrix.a - startVizMatrix.a) * progress;
        currentVizMatrix.b = startVizMatrix.b + (targetVizMatrix.b - startVizMatrix.b) * progress;
        currentVizMatrix.c = startVizMatrix.c + (targetVizMatrix.c - startVizMatrix.c) * progress;
        currentVizMatrix.d = startVizMatrix.d + (targetVizMatrix.d - startVizMatrix.d) * progress;
        
        // 插值计算当前平移
        currentVizTranslation.x = startVizTranslation.x + (targetVizTranslation.x - startVizTranslation.x) * progress;
        currentVizTranslation.y = startVizTranslation.y + (targetVizTranslation.y - startVizTranslation.y) * progress;
        
        drawVizFrame();
        
        if (progress < 1) {
            vizAnimationId = requestAnimationFrame(vizLoop);
        } else {
            isVizAnimating = false;
            vizAnimationId = null;
        }
    }
    
    // 核心绘制函数
    function drawVizFrame() {
        if (!ctx) return;
        
        // 清空画布
        ctx.clearRect(0, 0, vizWidth, vizHeight);
        
        // 保存上下文
        ctx.save();
        
        // 移动原点到中心
        const cx = vizWidth / 2;
        const cy = vizHeight / 2;
        ctx.translate(cx, cy);
        
        // 翻转Y轴，使向上为正
        ctx.scale(1, -1);
        
        const unit = 50; // 单位长度像素值
        
        // 绘制网格
        ctx.lineWidth = 1;
        const range = 15; // 网格范围
        
        // 辅助函数：应用线性变换 + 平移
        function transform(x, y) {
            // 先应用线性变换 (Rotation/Scale/Shear)
            // [a c] [x] = [ax + cy]
            // [b d] [y]   [bx + dy]
            let nx = currentVizMatrix.a * x + currentVizMatrix.c * y;
            let ny = currentVizMatrix.b * x + currentVizMatrix.d * y;
            
            // 再应用平移
            nx += currentVizTranslation.x;
            ny += currentVizTranslation.y;

            return {
                x: nx * unit,
                y: ny * unit
            };
        }
        
        // 绘制变换后的网格线
        for (let i = -range; i <= range; i++) {
            // 竖线 (x固定，y变化)
            ctx.beginPath();
            ctx.strokeStyle = (i === 0) ? '#333' : '#e0e0e0'; // 轴线深色，网格浅色
            ctx.lineWidth = (i === 0) ? 2 : 1;
            
            const p1 = transform(i, -range);
            const p2 = transform(i, range);
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            
            // 横线 (y固定，x变化)
            ctx.beginPath();
            ctx.strokeStyle = (i === 0) ? '#333' : '#e0e0e0';
            ctx.lineWidth = (i === 0) ? 2 : 1;
            
            const p3 = transform(-range, i);
            const p4 = transform(range, i);
            ctx.moveTo(p3.x, p3.y);
            ctx.lineTo(p4.x, p4.y);
            ctx.stroke();
        }

        // 绘制特征向量（如果在动画中或已勾选）
        if (document.getElementById('show-eigenvectors').checked) {
            drawEigenvectors(currentVizMatrix);
        }
        
        // 绘制基向量 i-hat (1, 0) -> 变换后
        // 注意：基向量通常附着在原点(0,0)，经过变换后附着在新的原点 (tx, ty)
        const origin = transform(0, 0);
        const i_hat_end = transform(1, 0);
        drawVector(origin.x, origin.y, i_hat_end.x, i_hat_end.y, '#2ecc71', 'i');
        
        // 绘制基向量 j-hat (0, 1) -> 变换后
        const j_hat_end = transform(0, 1);
        drawVector(origin.x, origin.y, j_hat_end.x, j_hat_end.y, '#e74c3c', 'j');
        
        ctx.restore();
    }

    // 绘制特征向量逻辑
    function drawEigenvectors(matrix) {
        // matrix: {a, b, c, d} -> [[a, c], [b, d]]
        const {a, b, c, d} = matrix;
        // 计算特征值：lambda^2 - tr*lambda + det = 0
        const tr = a + d;
        const det = a * d - b * c;
        const delta = tr * tr - 4 * det;

        if (delta < 0) return; // 无实数特征值

        const lambda1 = (tr + Math.sqrt(delta)) / 2;
        const lambda2 = (tr - Math.sqrt(delta)) / 2;

        const unit = 50;

        // 绘制单个特征向量所在的直线
        const drawVectorLine = (lambda, color) => {
            // (a - lambda)x + cy = 0
            // 解线性方程组找特征向量 v=(vx, vy)
            let vx, vy;
            // 避免除以零，选择系数较大的行来求解
            if (Math.abs(c) > 1e-6) {
                vx = 1;
                vy = -(a - lambda) / c;
            } else if (Math.abs(b) > 1e-6) {
                vx = -(d - lambda) / b;
                vy = 1;
            } else {
                // 对角矩阵或接近对角
                if (Math.abs(a - lambda) < 1e-6) { vx = 1; vy = 0; }
                else { vx = 0; vy = 1; }
            }

            // 归一化以便绘制
            const len = Math.sqrt(vx*vx + vy*vy);
            vx /= len;
            vy /= len;

            // 获取当前的变换原点 (即平移后的 (0,0))
            // 注意：transform已经包含了scale(unit)，我们这里只需要原点坐标
            // 为了绘制无限长直线，我们需要基于像素坐标
            // transform返回的是已经乘过unit的坐标
            const originPixels = { 
                x: currentVizTranslation.x * unit, 
                y: currentVizTranslation.y * unit 
            };
            
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]); // 虚线表示所在的直线跨度

            // 绘制一条贯穿屏幕的长线
            const scale = 500; 
            ctx.moveTo(originPixels.x - vx * scale, originPixels.y - vy * scale);
            ctx.lineTo(originPixels.x + vx * scale, originPixels.y + vy * scale);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // 绘制特征向量箭头 (长度为特征值大小? 或者固定长度指示方向)
            // 这里绘制固定长度指示方向
            drawVector(originPixels.x, originPixels.y, originPixels.x + vx * unit * 2, originPixels.y + vy * unit * 2, color, "v");
        };

        drawVectorLine(lambda1, '#f1c40f'); // 黄色
        // 如果有两个不同的特征值，再画第二个
        if (Math.abs(lambda1 - lambda2) > 1e-6) {
            drawVectorLine(lambda2, '#f39c12'); // 深黄色
        }
    }
    
    // 绘制向量箭头
    function drawVector(x1, y1, x2, y2, color, label) {
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = 3;
        
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        
        // 箭头头部
        const headLength = 10;
        const angle = Math.atan2(y2 - y1, x2 - x1);
        
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - headLength * Math.cos(angle - Math.PI / 6), y2 - headLength * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(x2 - headLength * Math.cos(angle + Math.PI / 6), y2 - headLength * Math.sin(angle + Math.PI / 6));
        ctx.fill();
        
        // 绘制标签（稍微偏离一点）
        // 此时y轴是反转的，所以文字要反转回来
        ctx.save();
        ctx.translate(x2 + 10, y2 + 10);
        ctx.scale(1, -1);
        ctx.font = 'bold 16px Arial';
        ctx.fillStyle = color; // 确保文字颜色一致
        ctx.fillText(label, 0, 0);
        ctx.restore();
    }
    
    </script>
</body>

</html>
